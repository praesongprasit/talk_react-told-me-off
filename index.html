<!doctype html>
<html lang="en-NZ">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
		<link rel="icon" type="image/png" href="img/icons/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="img/icons/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="img/icons/favicon-16x16.png" sizes="16x16">

		<link rel="apple-touch-icon" href="apple-touch-icon.png" sizes="180x180" />

		<link rel="manifest" href="manifest.json"/>
		<link rel="mask-icon" href="img/icons/safari-pinned-tab.svg" color="#A2DDD9">
		
		<meta name="msapplication-TileColor" content="#A2DDD9">
		<meta name="theme-color" content="#A2DDD9"/>
		<meta name="background-color" content="#fff"/>

		<meta property="og:url" content="https://praesongprasit.github.io/talk_react-told-me-off/" />
		<meta property="og:type" content="article">

		<meta property="og:image" name="twitter:image" content="https://praesongprasit.github.io/talk_react-told-me-off/repository-open-graph_img.png" />
		<meta property="og:image:alt" content="Light text on dark green background which said, Not accessible. React told me off! @PraeSongprasit"/>
		<meta property="og:image:type" content="image/png"/>
		<meta property="og:image:width" content="1280"/>
		<meta property="og:image:height" content="640"/>

		<meta property="og:title" name="twitter:title" content="Not accessible - React told me off!" />
		<meta property="og:description" name="twitter:description" content="I'm an engineer who cares about HTML output. I still make mistakes.
Often, front-end frameworks like React and Angular abstract HTML away. Even more so with design systems built on these frameworks. It's easy to forget to scrutinise the output during implementation.
The good news is, these frameworks are aware of the problem, and are constantly getting better at catching low-hanging fruit.
Let me show you a few ways React and React Testing Library told me off!" />

		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:dnt" content="on">
		<meta name="twitter:creator" content="@PraeSongprasit">

		<title>Not accessible - React told me off! by Prae Songprasit</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/personal-branding.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/zenburn.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<main class="slides">
				<section>
					<h1>Not accessible</h1>
					<p>React told me off!</p>
					<p class="small-text">
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Link to Prae Songprasit's twitter">@PraeSongprasit</a> and 
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Web Access Club podcast twitter">@WebAccessClub</a>
					</p>

					<aside class="notes">
						<p>Hi, I'm Prae, a Thai female with short dark hair. I'm wearing a big pair of dark framed glasses, and  [clothes].</p>
						<p>I'm a software engineer who cares about HTML output, and host of the Web Access Club podcast.</p>
						<p>I started my career in web as a junior designer.</p>
						<p>Within the first month, I realised that I didn't enjoy designing, but I sure enjoyed coding up people's designs with HTML and CSS. So I've been a front-end person ever since.</p>
						<p>I love creating responsive designs and improving usability of designs through code. I was mainly working on large information heavy sites for many years, so using HTML, CSS and a little touch of JavaScript was enough.</p>
						<p>That is how I've managed to avoid learning to code in modern JavaScript frameworks like React for most of my career.</p>
						<p>Majority of my previous projects focused on templating informative pages (like tourism websites), my testing knowledge only extends to manual multi-device regression testing, and network throttling in the browser to check site performance.</p>
						<p>Since my code is usually concerned with visuals, in a fixed budget fast-pace agency environment, I didn't know, or needed to know how to write tests for my front-end code.</p>
					</aside>
				</section>

				<section>
					<h2>Why test code?</h2>
					<p>
						Reduce errors on complex interactive sites
					</p>

					<aside class="notes">
						<p>This all changed, when I joined a team who works on a highly interactive web app, which was coded using React JavaScript framework.</p>
						<p>It was also when my job title changed from a developer to an engineer.</p>
						<p>Wow that was imposter syndrome inducing. I'm now expected to be able to 'engineer' websites, rather than simply 'develop' them.</p>
						<p>Suddenly, I'm not just making content available on a static page for my users.</p>
						<p>I'm providing users with different kinds of interactive elements, which let users do a lot more complex things on the page.</p>
					</aside>
				</section>

				<section>
					<img
							width="80%"
							src="img/todo_graphic.png"
							alt="Simplified UI of 4 to-do list states, empty, with an item added, done, and archived">

					<aside class="notes">
						<p>Think of to-do apps. It looks simple, a list title with lists of items.</p>
						<p>But there's a lot more to it than you think. I have to allow users to add whatever text they want as a dismissable list item.</p>
						<p>There's logic to control when a list item should be displayed, when it should appear in the 'done' or an 'archived' state, and when it should be permanently deleted. </p>
						<p>With so much microinteraction and power in the hands of my users, a lot more code could go wrong here. </p>
						<p>If I didn't code the list logic properly, selecting 'archive' a list item could permanently delete it by accident.</p>
						<p>And what happens, if someone uses a special character?</p>
						<p>Many JavaScript frameworks like React are designed, so that this sort of complex logic can be done in the browser, without forcing the users to refresh their browser. </p>
						<p>In the early days of the web, most logic that deals with content happens in the server, not the browser. </p>
						<p>So back-end developers who often use traditional imperative programming languages are expected to write tests, to ensure that the logic works as expected under different scenarios. It's good code quality control and development practice.</p>
						<p>But writing logical tests for front-end web interfaces is a much newer concept, especially for me. </p>
						<p>The first unit testing tool I've ever used was the React version of the open source library, called the 'Testing Library'.</p>
					</aside>
				</section>

				<section>
					<h2>React <br>Testing Library</h2>
					<p>Enforce user centric tests</p>

					<aside class="notes">
						<p>This testing library can be added to many front-end frameworks.</p>
						<p>But since I'm working with React, I only know how to use it with React at the moment.</p>
						<p>The Testing Library helps me test UI components in a user-centric way, like the way a user would use a component.</p>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape>
							&lt;Button
								label="Add a new fish"
								onClick="showInput(fishClass)"
							/&gt;
							
							&lt;Input
								aria-label="Fish name"
								class="fishClass"
							/&gt;
							<span class="fragment">
							showInput(fishClass)

							expect(&lt;Input class="fishClass"/&gt;) ü§Ø
							</span>
						</code>
					</pre>

					<aside class="notes">
						<p>For example, I was tasked to write tests for a button that would show an input field.</p>
						<p>[Read code from slide]</p>
						<p>A note that in this example, Input field doesn't have a visible label... and used aria-label.... I've only done that to shorten the slide.</p>
						<p>Please add a visible label and link it to input using for and ID instead!!</p>
						<hr>
						<p>Anyway...</p>
						<p>In the past, the back-end style of writing tests, would focus on testing the function and implementation itself. In this case, the test would:</p>
						<p>[Next, Read code from slide]</p>
						<p>The problem I have with this, is that it only tests if the input field with a class name "fishClass" appears on the page when that code is executed. The test doesn't care if there's an accessible name called "Fish name" attached to that newly rendered input field.</p>
						<p>That's not how users think about this interface.</p>
						<p>Users don't care about a classname? CSS classes are not visible to users on the page; their screen reader won't read it, and voice dictation tools can't find an element using CSS class.</p>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape>
							&lt;Button
								label="Add a new fish"
								onClick="showInput(fishClass)"
							/&gt;
							
							&lt;Input
								aria-label="Fish name"
								class="fishClass"
							/&gt;
							
							userEvent.click(screen.getByText('Add a new fish'));

							expect(
								screen.getByRole('input', { name: 'Fish name' })
							).toBeInTheDocument(); ‚ù§Ô∏è
						</code>
					</pre>

					<aside class="notes">
						<p>To the user, a button called "Add a new fish" was clicked, and an input field with an accessible name called "Fish name" appeared.</p>
						<p>React Testing Library is accessibility-first like that.</p>
						<p>It encourages engineers to write tests that queries accessible names and DOM roles, rather than arbitrary IDs and Classes that users don't care about.</p>
						<p>You can query by other useful static things like ByTitle, ByAltText, ByDisplayValue, even interactive states like pressed, checked, selected.</p>
						<p>This is fantastic, because if the test cannot access those values, then something is seriously inaccessible about your code.</p>
						<p>I once spotted an issue, where a hidden attribute accidentally remained attached to a component that should be displaying, because the query said it couldn't find this hidden text.</p>
					</aside>
				</section>

				<section>
					<h2>What about React?</h2>
					<p>Improved docs, <br>development assistance, &amp; bundling</p>

					<aside class="notes">
						<p>I talked quite a bit about the React version of Testing Library.</p>
						<p>But as the name suggests, it's a library. Something designed to be used in conjunction with a framework. It's not React itself.</p>
						<p>So what does React itself actually do to help nudge engineers to write more accessible code?</p>
						<hr>
						<p>First, it tries to improve documentation.</p>
						<p>They also understand that beginners copy and paste code quite blindly when learning. So their copy-paste examples all throughout their docs are getting better and more accessibility conscious all the time.</p>
						<p>That is of course, human intervention. Requires reading. What about machine intervention?</p>
						<hr>
						<p>Second, it provide basic development assistance</p>
						<p>Everyone makes mistakes. Whenever possible, let tools instead of people tell them off.</p>
						<p>There are some basic accessibility linting that came with React.</p>
						<p>It would highlight an HTML attribute that isn't right for a specific type of element with a red squiggly line like when you made a typo, and would show warnings in the console.</p>
					</aside>
				</section>

				<section>
					<pre>
						<code data-trim data-noescape>
							&lt;input tabindex="0"/&gt;
							<span class="fragment">
							Type '{ tabindex: string; "aria-label": string; }' 
							is not assignable to type 
							'DetailedHTMLProps&lt;InputHTMLAttributes
							&lt;HTMLInputElement&gt;, HTMLInputElement&gt;'.
								
							Property 'tabindex' does not exist on type
							'DetailedHTMLProps&lt;InputHTMLAttributes
							&lt;HTMLInputElement&gt;, HTMLInputElement&gt;'.
							Did you mean 'tabIndex'?
							</span>
						</code>
					</pre>

					<aside class="notes">
						<p>An example, would be</p>
						<p>[Read code from slide]</p>
						<p>The linting message said:</p>
						<p>[Next, Read code from slide]</p>
						<p>It's basically saying that I shouldn't be allowed to put tabindex on an input.</p>
						<p>React also highly recommended other complimentary development plugins like eslint-plugin-jsx-a11y, which provides more accessibility linting feedback as you code in your favourite code editor. </p>
						<p>The last thing React did, was to recommend good practices in Create React App starter guide</p>
					</aside>
				</section>

				<section>
					<p>Create React App</p>
					<img
							width="40%"
							src="img/create-react-app.svg"
							alt="Simplified UI of 4 to-do list states, empty, with an item added, done, and archived">

					<aside class="notes">
						<p>Create React App's is a bootstrap kit for starting a new React project.</p>
						<p>React understand that it's crucial to add best practices to starter kits, because that's usually how someone starts learning how to build with React.</p>
						<p>Who reads documentation?!</p>
						<p>React Testing Library and the linting tools mentioned in main React docs is also mentioned in Create React App guides, along with other accessibility best practices</p>
					</aside>
				</section>

				<section>
					<h2>People can <br>ignore tests?!</h2>
					<p class="fragment" data-fragment-index="1">
						Yes... but you can make it harder
					</p>
					<aside class="notes">
						<p>But wait‚Ä¶ this is real life. Can't people also just ignore or by-pass these tests?</p>
						<p>Yes, and no. Depends.</p>
						<p>For React Testing Library, if you don't write any tests as a part of your usual development process, then of course you won't reap these benefits.</p>
					</aside>
				</section>

				<section>
					<h2>Bake it in</h2>
					<p>
						TDD, prevent commits &amp; stop deploys
					</p>
					<aside class="notes">
						<p>But if your team does test driven development, where you write tests first, then write real code which would fix the test, then this will slot right into your workflow </p>
						<p>As for development assistance like linting‚Ä¶ You <em>can</em> turn some linting tools off, like additional libraries or extensions attached to your code editor. And frustratingly, many engineers unfamiliar with front-end landscape do. So engineers could simply ignore many linting warnings.</p>
						<p>You can put in the last resort, of making sure that people cannot deploy code without passing accessibility related tests.</p>
						<p>You can chain accessibility linter to the same test command you use before committing, pushing, and or continuous deployment can happen.</p>
						<p>If the tests fail, then the engineers won't be able to push code or run a successful build and deploy that code to production.</p>
						<p>Let the bots tell people off‚Ä¶ rather than your team mates.</p>
					</aside>
				</section>

				<section>
					<h2>React told me off</h2>
					<p>
						...but not all the time
					</p>

					<aside class="notes">
						<p>As you can see, React, React Testing Library, and other accessibility linting tools are trying to improve accessibility in several ways:</p>
						<ol>
							<li><p>It tries to change the way you approach writing tests. To think more along the lines of what users do on the page, and querying accessible names or roles to check if something works as expected</p></li>
							<li><p>It tries to embed basic accessibility as a part of the development process or deployment pipeline</p></li>
							<li><p>It tries to nudge you to add important things like alt tags to images, and accessible names in links and buttons.</p></li>
						</ol>
						<p>It tries to nudge you to add important things like alt tags to images, and accessible names in links and buttons.</p>
						<p>It will tell me off, if my element doesn't have an accessible name. But robots don't understand what the 'correct' accessible name looks like. </p>
						<p>If I wasn't an HTML conscious engineer, I may have fixed the issue by putting a random text in as an element's accessible name and calling it the day. I can't properly address low-hanging issues raised by tooling, without understanding why that was considered an issue.</p>
						<p>Copy is a core part of good UX design. And as of now, AI hasn't gotten smart enough to be the judge of what a good copy looks like yet. </p>
						<p>So yes, React could tell me off for writing some inaccessible code. </p>
						<p>But we still have to rely on human coders, testers, and designers to figure out what makes sense for our UI.</p>
					</aside>
				</section>

				<section>
					<blockquote>
						Accessibility is a mindset,<br>not a standalone activity
					</blockquote>
					<p class="small-text">
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Link to Prae Songprasit's twitter">@PraeSongprasit</a> and 
						<a rel="external" href="https://twitter.com/PraeSongprasit" alt="Web Access Club podcast twitter">@WebAccessClub</a>
					</p>

					<aside class="notes">
						<p>It's important to remember that accessibility isn't a standalone thing that you can test in isolation. </p>
						<p>It's a mindset of creating a usable experience for everyone.</p>
						<p>It still needs humans to work together to create something truly inclusive.</p>
					</aside>
				</section>
			</main>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				transition: 'none',
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
